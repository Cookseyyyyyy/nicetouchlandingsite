import{r as z,j as p}from"./index-BJHAE5s4.js";/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const ct="172",G=2e3,ht=2001;function f(S,t,s){return Math.max(t,Math.min(s,S))}class nt{constructor(t=0,s=0){nt.prototype.isVector2=!0,this.x=t,this.y=s}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,s){return this.x=t,this.y=s,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const s=this.x,i=this.y,e=t.elements;return this.x=e[0]*s+e[3]*i+e[6],this.y=e[1]*s+e[4]*i+e[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,s){return this.x=f(this.x,t.x,s.x),this.y=f(this.y,t.y,s.y),this}clampScalar(t,s){return this.x=f(this.x,t,s),this.y=f(this.y,t,s),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(f(i,t,s))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(s===0)return Math.PI/2;const i=this.dot(t)/s;return Math.acos(f(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y;return s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this}rotateAround(t,s){const i=Math.cos(s),e=Math.sin(s),n=this.x-t.x,r=this.y-t.y;return this.x=n*i-r*e+t.x,this.y=n*e+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class lt{constructor(t=0,s=0,i=0,e=1){this.isQuaternion=!0,this._x=t,this._y=s,this._z=i,this._w=e}static slerpFlat(t,s,i,e,n,r,a){let h=i[e+0],c=i[e+1],u=i[e+2],o=i[e+3];const l=n[r+0],y=n[r+1],x=n[r+2],m=n[r+3];if(a===0){t[s+0]=h,t[s+1]=c,t[s+2]=u,t[s+3]=o;return}if(a===1){t[s+0]=l,t[s+1]=y,t[s+2]=x,t[s+3]=m;return}if(o!==m||h!==l||c!==y||u!==x){let _=1-a;const d=h*l+c*y+u*x+o*m,k=d>=0?1:-1,T=1-d*d;if(T>Number.EPSILON){const g=Math.sqrt(T),C=Math.atan2(g,d*k);_=Math.sin(_*C)/g,a=Math.sin(a*C)/g}const b=a*k;if(h=h*_+l*b,c=c*_+y*b,u=u*_+x*b,o=o*_+m*b,_===1-a){const g=1/Math.sqrt(h*h+c*c+u*u+o*o);h*=g,c*=g,u*=g,o*=g}}t[s]=h,t[s+1]=c,t[s+2]=u,t[s+3]=o}static multiplyQuaternionsFlat(t,s,i,e,n,r){const a=i[e],h=i[e+1],c=i[e+2],u=i[e+3],o=n[r],l=n[r+1],y=n[r+2],x=n[r+3];return t[s]=a*x+u*o+h*y-c*l,t[s+1]=h*x+u*l+c*o-a*y,t[s+2]=c*x+u*y+a*l-h*o,t[s+3]=u*x-a*o-h*l-c*y,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,i,e){return this._x=t,this._y=s,this._z=i,this._w=e,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s=!0){const i=t._x,e=t._y,n=t._z,r=t._order,a=Math.cos,h=Math.sin,c=a(i/2),u=a(e/2),o=a(n/2),l=h(i/2),y=h(e/2),x=h(n/2);switch(r){case"XYZ":this._x=l*u*o+c*y*x,this._y=c*y*o-l*u*x,this._z=c*u*x+l*y*o,this._w=c*u*o-l*y*x;break;case"YXZ":this._x=l*u*o+c*y*x,this._y=c*y*o-l*u*x,this._z=c*u*x-l*y*o,this._w=c*u*o+l*y*x;break;case"ZXY":this._x=l*u*o-c*y*x,this._y=c*y*o+l*u*x,this._z=c*u*x+l*y*o,this._w=c*u*o-l*y*x;break;case"ZYX":this._x=l*u*o-c*y*x,this._y=c*y*o+l*u*x,this._z=c*u*x-l*y*o,this._w=c*u*o+l*y*x;break;case"YZX":this._x=l*u*o+c*y*x,this._y=c*y*o+l*u*x,this._z=c*u*x-l*y*o,this._w=c*u*o-l*y*x;break;case"XZY":this._x=l*u*o-c*y*x,this._y=c*y*o-l*u*x,this._z=c*u*x+l*y*o,this._w=c*u*o+l*y*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return s===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const i=s/2,e=Math.sin(i);return this._x=t.x*e,this._y=t.y*e,this._z=t.z*e,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,i=s[0],e=s[4],n=s[8],r=s[1],a=s[5],h=s[9],c=s[2],u=s[6],o=s[10],l=i+a+o;if(l>0){const y=.5/Math.sqrt(l+1);this._w=.25/y,this._x=(u-h)*y,this._y=(n-c)*y,this._z=(r-e)*y}else if(i>a&&i>o){const y=2*Math.sqrt(1+i-a-o);this._w=(u-h)/y,this._x=.25*y,this._y=(e+r)/y,this._z=(n+c)/y}else if(a>o){const y=2*Math.sqrt(1+a-i-o);this._w=(n-c)/y,this._x=(e+r)/y,this._y=.25*y,this._z=(h+u)/y}else{const y=2*Math.sqrt(1+o-i-a);this._w=(r-e)/y,this._x=(n+c)/y,this._y=(h+u)/y,this._z=.25*y}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let i=t.dot(s)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(f(this.dot(t),-1,1)))}rotateTowards(t,s){const i=this.angleTo(t);if(i===0)return this;const e=Math.min(1,s/i);return this.slerp(t,e),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const i=t._x,e=t._y,n=t._z,r=t._w,a=s._x,h=s._y,c=s._z,u=s._w;return this._x=i*u+r*a+e*c-n*h,this._y=e*u+r*h+n*a-i*c,this._z=n*u+r*c+i*h-e*a,this._w=r*u-i*a-e*h-n*c,this._onChangeCallback(),this}slerp(t,s){if(s===0)return this;if(s===1)return this.copy(t);const i=this._x,e=this._y,n=this._z,r=this._w;let a=r*t._w+i*t._x+e*t._y+n*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=r,this._x=i,this._y=e,this._z=n,this;const h=1-a*a;if(h<=Number.EPSILON){const y=1-s;return this._w=y*r+s*this._w,this._x=y*i+s*this._x,this._y=y*e+s*this._y,this._z=y*n+s*this._z,this.normalize(),this}const c=Math.sqrt(h),u=Math.atan2(c,a),o=Math.sin((1-s)*u)/c,l=Math.sin(s*u)/c;return this._w=r*o+this._w*l,this._x=i*o+this._x*l,this._y=e*o+this._y*l,this._z=n*o+this._z*l,this._onChangeCallback(),this}slerpQuaternions(t,s,i){return this.copy(t).slerp(s,i)}random(){const t=2*Math.PI*Math.random(),s=2*Math.PI*Math.random(),i=Math.random(),e=Math.sqrt(1-i),n=Math.sqrt(i);return this.set(e*Math.sin(t),e*Math.cos(t),n*Math.sin(s),n*Math.cos(s))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class w{constructor(t=0,s=0,i=0){w.prototype.isVector3=!0,this.x=t,this.y=s,this.z=i}set(t,s,i){return i===void 0&&(i=this.z),this.x=t,this.y=s,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return this.applyQuaternion(rt.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(rt.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,i=this.y,e=this.z,n=t.elements;return this.x=n[0]*s+n[3]*i+n[6]*e,this.y=n[1]*s+n[4]*i+n[7]*e,this.z=n[2]*s+n[5]*i+n[8]*e,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,i=this.y,e=this.z,n=t.elements,r=1/(n[3]*s+n[7]*i+n[11]*e+n[15]);return this.x=(n[0]*s+n[4]*i+n[8]*e+n[12])*r,this.y=(n[1]*s+n[5]*i+n[9]*e+n[13])*r,this.z=(n[2]*s+n[6]*i+n[10]*e+n[14])*r,this}applyQuaternion(t){const s=this.x,i=this.y,e=this.z,n=t.x,r=t.y,a=t.z,h=t.w,c=2*(r*e-a*i),u=2*(a*s-n*e),o=2*(n*i-r*s);return this.x=s+h*c+r*o-a*u,this.y=i+h*u+a*c-n*o,this.z=e+h*o+n*u-r*c,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,i=this.y,e=this.z,n=t.elements;return this.x=n[0]*s+n[4]*i+n[8]*e,this.y=n[1]*s+n[5]*i+n[9]*e,this.z=n[2]*s+n[6]*i+n[10]*e,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=f(this.x,t.x,s.x),this.y=f(this.y,t.y,s.y),this.z=f(this.z,t.z,s.z),this}clampScalar(t,s){return this.x=f(this.x,t,s),this.y=f(this.y,t,s),this.z=f(this.z,t,s),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(f(i,t,s))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,s){const i=t.x,e=t.y,n=t.z,r=s.x,a=s.y,h=s.z;return this.x=e*h-n*a,this.y=n*r-i*h,this.z=i*a-e*r,this}projectOnVector(t){const s=t.lengthSq();if(s===0)return this.set(0,0,0);const i=t.dot(this)/s;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return v.copy(this).projectOnVector(t),this.sub(v)}reflect(t){return this.sub(v.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(s===0)return Math.PI/2;const i=this.dot(t)/s;return Math.acos(f(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y,e=this.z-t.z;return s*s+i*i+e*e}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,i){const e=Math.sin(s)*t;return this.x=e*Math.sin(i),this.y=Math.cos(s)*t,this.z=e*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,i){return this.x=t*Math.sin(s),this.y=i,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),e=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=i,this.z=e,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,s*4)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,s*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,s=Math.random()*2-1,i=Math.sqrt(1-s*s);return this.x=i*Math.cos(t),this.y=s,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const v=new w,rt=new lt,q=new w,tt=new w,J=new w,P=new w,st=new w,K=new w,it=new w;class ut{constructor(t=new w,s=new w(0,0,-1)){this.origin=t,this.direction=s}set(t,s){return this.origin.copy(t),this.direction.copy(s),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,s){return s.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,q)),this}closestPointToPoint(t,s){s.subVectors(t,this.origin);const i=s.dot(this.direction);return i<0?s.copy(this.origin):s.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const s=q.subVectors(t,this.origin).dot(this.direction);return s<0?this.origin.distanceToSquared(t):(q.copy(this.origin).addScaledVector(this.direction,s),q.distanceToSquared(t))}distanceSqToSegment(t,s,i,e){tt.copy(t).add(s).multiplyScalar(.5),J.copy(s).sub(t).normalize(),P.copy(this.origin).sub(tt);const n=t.distanceTo(s)*.5,r=-this.direction.dot(J),a=P.dot(this.direction),h=-P.dot(J),c=P.lengthSq(),u=Math.abs(1-r*r);let o,l,y,x;if(u>0)if(o=r*h-a,l=r*a-h,x=n*u,o>=0)if(l>=-x)if(l<=x){const m=1/u;o*=m,l*=m,y=o*(o+r*l+2*a)+l*(r*o+l+2*h)+c}else l=n,o=Math.max(0,-(r*l+a)),y=-o*o+l*(l+2*h)+c;else l=-n,o=Math.max(0,-(r*l+a)),y=-o*o+l*(l+2*h)+c;else l<=-x?(o=Math.max(0,-(-r*n+a)),l=o>0?-n:Math.min(Math.max(-n,-h),n),y=-o*o+l*(l+2*h)+c):l<=x?(o=0,l=Math.min(Math.max(-n,-h),n),y=l*(l+2*h)+c):(o=Math.max(0,-(r*n+a)),l=o>0?n:Math.min(Math.max(-n,-h),n),y=-o*o+l*(l+2*h)+c);else l=r>0?-n:n,o=Math.max(0,-(r*l+a)),y=-o*o+l*(l+2*h)+c;return i&&i.copy(this.origin).addScaledVector(this.direction,o),e&&e.copy(tt).addScaledVector(J,l),y}intersectSphere(t,s){q.subVectors(t.center,this.origin);const i=q.dot(this.direction),e=q.dot(q)-i*i,n=t.radius*t.radius;if(e>n)return null;const r=Math.sqrt(n-e),a=i-r,h=i+r;return h<0?null:a<0?this.at(h,s):this.at(a,s)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const s=t.normal.dot(this.direction);if(s===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/s;return i>=0?i:null}intersectPlane(t,s){const i=this.distanceToPlane(t);return i===null?null:this.at(i,s)}intersectsPlane(t){const s=t.distanceToPoint(this.origin);return s===0||t.normal.dot(this.direction)*s<0}intersectBox(t,s){let i,e,n,r,a,h;const c=1/this.direction.x,u=1/this.direction.y,o=1/this.direction.z,l=this.origin;return c>=0?(i=(t.min.x-l.x)*c,e=(t.max.x-l.x)*c):(i=(t.max.x-l.x)*c,e=(t.min.x-l.x)*c),u>=0?(n=(t.min.y-l.y)*u,r=(t.max.y-l.y)*u):(n=(t.max.y-l.y)*u,r=(t.min.y-l.y)*u),i>r||n>e||((n>i||isNaN(i))&&(i=n),(r<e||isNaN(e))&&(e=r),o>=0?(a=(t.min.z-l.z)*o,h=(t.max.z-l.z)*o):(a=(t.max.z-l.z)*o,h=(t.min.z-l.z)*o),i>h||a>e)||((a>i||i!==i)&&(i=a),(h<e||e!==e)&&(e=h),e<0)?null:this.at(i>=0?i:e,s)}intersectsBox(t){return this.intersectBox(t,q)!==null}intersectTriangle(t,s,i,e,n){st.subVectors(s,t),K.subVectors(i,t),it.crossVectors(st,K);let r=this.direction.dot(it),a;if(r>0){if(e)return null;a=1}else if(r<0)a=-1,r=-r;else return null;P.subVectors(this.origin,t);const h=a*this.direction.dot(K.crossVectors(P,K));if(h<0)return null;const c=a*this.direction.dot(st.cross(P));if(c<0||h+c>r)return null;const u=-a*P.dot(it);return u<0?null:this.at(u/r,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class j{constructor(t,s,i,e,n,r,a,h,c,u,o,l,y,x,m,_){j.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,s,i,e,n,r,a,h,c,u,o,l,y,x,m,_)}set(t,s,i,e,n,r,a,h,c,u,o,l,y,x,m,_){const d=this.elements;return d[0]=t,d[4]=s,d[8]=i,d[12]=e,d[1]=n,d[5]=r,d[9]=a,d[13]=h,d[2]=c,d[6]=u,d[10]=o,d[14]=l,d[3]=y,d[7]=x,d[11]=m,d[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new j().fromArray(this.elements)}copy(t){const s=this.elements,i=t.elements;return s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=i[3],s[4]=i[4],s[5]=i[5],s[6]=i[6],s[7]=i[7],s[8]=i[8],s[9]=i[9],s[10]=i[10],s[11]=i[11],s[12]=i[12],s[13]=i[13],s[14]=i[14],s[15]=i[15],this}copyPosition(t){const s=this.elements,i=t.elements;return s[12]=i[12],s[13]=i[13],s[14]=i[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,i){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,s,i){return this.set(t.x,s.x,i.x,0,t.y,s.y,i.y,0,t.z,s.z,i.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,i=t.elements,e=1/V.setFromMatrixColumn(t,0).length(),n=1/V.setFromMatrixColumn(t,1).length(),r=1/V.setFromMatrixColumn(t,2).length();return s[0]=i[0]*e,s[1]=i[1]*e,s[2]=i[2]*e,s[3]=0,s[4]=i[4]*n,s[5]=i[5]*n,s[6]=i[6]*n,s[7]=0,s[8]=i[8]*r,s[9]=i[9]*r,s[10]=i[10]*r,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){const s=this.elements,i=t.x,e=t.y,n=t.z,r=Math.cos(i),a=Math.sin(i),h=Math.cos(e),c=Math.sin(e),u=Math.cos(n),o=Math.sin(n);if(t.order==="XYZ"){const l=r*u,y=r*o,x=a*u,m=a*o;s[0]=h*u,s[4]=-h*o,s[8]=c,s[1]=y+x*c,s[5]=l-m*c,s[9]=-a*h,s[2]=m-l*c,s[6]=x+y*c,s[10]=r*h}else if(t.order==="YXZ"){const l=h*u,y=h*o,x=c*u,m=c*o;s[0]=l+m*a,s[4]=x*a-y,s[8]=r*c,s[1]=r*o,s[5]=r*u,s[9]=-a,s[2]=y*a-x,s[6]=m+l*a,s[10]=r*h}else if(t.order==="ZXY"){const l=h*u,y=h*o,x=c*u,m=c*o;s[0]=l-m*a,s[4]=-r*o,s[8]=x+y*a,s[1]=y+x*a,s[5]=r*u,s[9]=m-l*a,s[2]=-r*c,s[6]=a,s[10]=r*h}else if(t.order==="ZYX"){const l=r*u,y=r*o,x=a*u,m=a*o;s[0]=h*u,s[4]=x*c-y,s[8]=l*c+m,s[1]=h*o,s[5]=m*c+l,s[9]=y*c-x,s[2]=-c,s[6]=a*h,s[10]=r*h}else if(t.order==="YZX"){const l=r*h,y=r*c,x=a*h,m=a*c;s[0]=h*u,s[4]=m-l*o,s[8]=x*o+y,s[1]=o,s[5]=r*u,s[9]=-a*u,s[2]=-c*u,s[6]=y*o+x,s[10]=l-m*o}else if(t.order==="XZY"){const l=r*h,y=r*c,x=a*h,m=a*c;s[0]=h*u,s[4]=-o,s[8]=c*u,s[1]=l*o+m,s[5]=r*u,s[9]=y*o-x,s[2]=x*o-y,s[6]=a*u,s[10]=m*o+l}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(yt,t,xt)}lookAt(t,s,i){const e=this.elements;return E.subVectors(t,s),E.lengthSq()===0&&(E.z=1),E.normalize(),N.crossVectors(i,E),N.lengthSq()===0&&(Math.abs(i.z)===1?E.x+=1e-4:E.z+=1e-4,E.normalize(),N.crossVectors(i,E)),N.normalize(),O.crossVectors(E,N),e[0]=N.x,e[4]=O.x,e[8]=E.x,e[1]=N.y,e[5]=O.y,e[9]=E.y,e[2]=N.z,e[6]=O.z,e[10]=E.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const i=t.elements,e=s.elements,n=this.elements,r=i[0],a=i[4],h=i[8],c=i[12],u=i[1],o=i[5],l=i[9],y=i[13],x=i[2],m=i[6],_=i[10],d=i[14],k=i[3],T=i[7],b=i[11],g=i[15],C=e[0],M=e[4],A=e[8],F=e[12],I=e[1],Y=e[5],D=e[9],X=e[13],Z=e[2],L=e[6],B=e[10],Q=e[14],H=e[3],W=e[7],U=e[11],$=e[15];return n[0]=r*C+a*I+h*Z+c*H,n[4]=r*M+a*Y+h*L+c*W,n[8]=r*A+a*D+h*B+c*U,n[12]=r*F+a*X+h*Q+c*$,n[1]=u*C+o*I+l*Z+y*H,n[5]=u*M+o*Y+l*L+y*W,n[9]=u*A+o*D+l*B+y*U,n[13]=u*F+o*X+l*Q+y*$,n[2]=x*C+m*I+_*Z+d*H,n[6]=x*M+m*Y+_*L+d*W,n[10]=x*A+m*D+_*B+d*U,n[14]=x*F+m*X+_*Q+d*$,n[3]=k*C+T*I+b*Z+g*H,n[7]=k*M+T*Y+b*L+g*W,n[11]=k*A+T*D+b*B+g*U,n[15]=k*F+T*X+b*Q+g*$,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],i=t[4],e=t[8],n=t[12],r=t[1],a=t[5],h=t[9],c=t[13],u=t[2],o=t[6],l=t[10],y=t[14],x=t[3],m=t[7],_=t[11],d=t[15];return x*(+n*h*o-e*c*o-n*a*l+i*c*l+e*a*y-i*h*y)+m*(+s*h*y-s*c*l+n*r*l-e*r*y+e*c*u-n*h*u)+_*(+s*c*o-s*a*y-n*r*o+i*r*y+n*a*u-i*c*u)+d*(-e*a*u-s*h*o+s*a*l+e*r*o-i*r*l+i*h*u)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,i){const e=this.elements;return t.isVector3?(e[12]=t.x,e[13]=t.y,e[14]=t.z):(e[12]=t,e[13]=s,e[14]=i),this}invert(){const t=this.elements,s=t[0],i=t[1],e=t[2],n=t[3],r=t[4],a=t[5],h=t[6],c=t[7],u=t[8],o=t[9],l=t[10],y=t[11],x=t[12],m=t[13],_=t[14],d=t[15],k=o*_*c-m*l*c+m*h*y-a*_*y-o*h*d+a*l*d,T=x*l*c-u*_*c-x*h*y+r*_*y+u*h*d-r*l*d,b=u*m*c-x*o*c+x*a*y-r*m*y-u*a*d+r*o*d,g=x*o*h-u*m*h-x*a*l+r*m*l+u*a*_-r*o*_,C=s*k+i*T+e*b+n*g;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const M=1/C;return t[0]=k*M,t[1]=(m*l*n-o*_*n-m*e*y+i*_*y+o*e*d-i*l*d)*M,t[2]=(a*_*n-m*h*n+m*e*c-i*_*c-a*e*d+i*h*d)*M,t[3]=(o*h*n-a*l*n-o*e*c+i*l*c+a*e*y-i*h*y)*M,t[4]=T*M,t[5]=(u*_*n-x*l*n+x*e*y-s*_*y-u*e*d+s*l*d)*M,t[6]=(x*h*n-r*_*n-x*e*c+s*_*c+r*e*d-s*h*d)*M,t[7]=(r*l*n-u*h*n+u*e*c-s*l*c-r*e*y+s*h*y)*M,t[8]=b*M,t[9]=(x*o*n-u*m*n-x*i*y+s*m*y+u*i*d-s*o*d)*M,t[10]=(r*m*n-x*a*n+x*i*c-s*m*c-r*i*d+s*a*d)*M,t[11]=(u*a*n-r*o*n-u*i*c+s*o*c+r*i*y-s*a*y)*M,t[12]=g*M,t[13]=(u*m*e-x*o*e+x*i*l-s*m*l-u*i*_+s*o*_)*M,t[14]=(x*a*e-r*m*e-x*i*h+s*m*h+r*i*_-s*a*_)*M,t[15]=(r*o*e-u*a*e+u*i*h-s*o*h-r*i*l+s*a*l)*M,this}scale(t){const s=this.elements,i=t.x,e=t.y,n=t.z;return s[0]*=i,s[4]*=e,s[8]*=n,s[1]*=i,s[5]*=e,s[9]*=n,s[2]*=i,s[6]*=e,s[10]*=n,s[3]*=i,s[7]*=e,s[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],e=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,i,e))}makeTranslation(t,s,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,s,0,0,1,i,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,s,-i,0,0,i,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,0,i,0,0,1,0,0,-i,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,-i,0,0,i,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const i=Math.cos(s),e=Math.sin(s),n=1-i,r=t.x,a=t.y,h=t.z,c=n*r,u=n*a;return this.set(c*r+i,c*a-e*h,c*h+e*a,0,c*a+e*h,u*a+i,u*h-e*r,0,c*h-e*a,u*h+e*r,n*h*h+i,0,0,0,0,1),this}makeScale(t,s,i){return this.set(t,0,0,0,0,s,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,s,i,e,n,r){return this.set(1,i,n,0,t,1,r,0,s,e,1,0,0,0,0,1),this}compose(t,s,i){const e=this.elements,n=s._x,r=s._y,a=s._z,h=s._w,c=n+n,u=r+r,o=a+a,l=n*c,y=n*u,x=n*o,m=r*u,_=r*o,d=a*o,k=h*c,T=h*u,b=h*o,g=i.x,C=i.y,M=i.z;return e[0]=(1-(m+d))*g,e[1]=(y+b)*g,e[2]=(x-T)*g,e[3]=0,e[4]=(y-b)*C,e[5]=(1-(l+d))*C,e[6]=(_+k)*C,e[7]=0,e[8]=(x+T)*M,e[9]=(_-k)*M,e[10]=(1-(l+m))*M,e[11]=0,e[12]=t.x,e[13]=t.y,e[14]=t.z,e[15]=1,this}decompose(t,s,i){const e=this.elements;let n=V.set(e[0],e[1],e[2]).length();const r=V.set(e[4],e[5],e[6]).length(),a=V.set(e[8],e[9],e[10]).length();this.determinant()<0&&(n=-n),t.x=e[12],t.y=e[13],t.z=e[14],R.copy(this);const c=1/n,u=1/r,o=1/a;return R.elements[0]*=c,R.elements[1]*=c,R.elements[2]*=c,R.elements[4]*=u,R.elements[5]*=u,R.elements[6]*=u,R.elements[8]*=o,R.elements[9]*=o,R.elements[10]*=o,s.setFromRotationMatrix(R),i.x=n,i.y=r,i.z=a,this}makePerspective(t,s,i,e,n,r,a=G){const h=this.elements,c=2*n/(s-t),u=2*n/(i-e),o=(s+t)/(s-t),l=(i+e)/(i-e);let y,x;if(a===G)y=-(r+n)/(r-n),x=-2*r*n/(r-n);else if(a===ht)y=-r/(r-n),x=-r*n/(r-n);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return h[0]=c,h[4]=0,h[8]=o,h[12]=0,h[1]=0,h[5]=u,h[9]=l,h[13]=0,h[2]=0,h[6]=0,h[10]=y,h[14]=x,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,s,i,e,n,r,a=G){const h=this.elements,c=1/(s-t),u=1/(i-e),o=1/(r-n),l=(s+t)*c,y=(i+e)*u;let x,m;if(a===G)x=(r+n)*o,m=-2*o;else if(a===ht)x=n*o,m=-1*o;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return h[0]=2*c,h[4]=0,h[8]=0,h[12]=-l,h[1]=0,h[5]=2*u,h[9]=0,h[13]=-y,h[2]=0,h[6]=0,h[10]=m,h[14]=-x,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const s=this.elements,i=t.elements;for(let e=0;e<16;e++)if(s[e]!==i[e])return!1;return!0}fromArray(t,s=0){for(let i=0;i<16;i++)this.elements[i]=t[i+s];return this}toArray(t=[],s=0){const i=this.elements;return t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t[s+9]=i[9],t[s+10]=i[10],t[s+11]=i[11],t[s+12]=i[12],t[s+13]=i[13],t[s+14]=i[14],t[s+15]=i[15],t}}const V=new w,R=new j,yt=new w(0,0,0),xt=new w(1,1,1),N=new w,O=new w,E=new w;class mt{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}const ot=new j;class dt{constructor(t,s,i=0,e=1/0){this.ray=new ut(t,s),this.near=i,this.far=e,this.camera=null,this.layers=new mt,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,s){this.ray.set(t,s)}setFromCamera(t,s){s.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(s.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(s).sub(this.ray.origin).normalize(),this.camera=s):s.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(s.near+s.far)/(s.near-s.far)).unproject(s),this.ray.direction.set(0,0,-1).transformDirection(s.matrixWorld),this.camera=s):console.error("THREE.Raycaster: Unsupported camera type: "+s.type)}setFromXRController(t){return ot.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(ot),this}intersectObject(t,s=!0,i=[]){return et(t,this,i,s),i.sort(at),i}intersectObjects(t,s=!0,i=[]){for(let e=0,n=t.length;e<n;e++)et(t[e],this,i,s);return i.sort(at),i}}function at(S,t){return S.distance-t.distance}function et(S,t,s,i){let e=!0;if(S.layers.test(t.layers)&&S.raycast(t,s)===!1&&(e=!1),e===!0&&i===!0){const n=S.children;for(let r=0,a=n.length;r<a;r++)et(n[r],t,s,!0)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:ct}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=ct);const _t=({gridWidth:S=10,gridHeight:t=10,gridDepth:s=2})=>{const i=z.useRef(null);z.useRef(null),z.useRef(null),z.useRef(null),z.useRef(null),z.useRef(null),z.useRef(null),z.useRef(null),z.useRef([]),z.useRef(null),z.useRef(null),z.useRef(new dt),z.useRef(new nt),z.useRef(!1),z.useRef(-1),z.useRef(1/60),z.useRef(0);const[e,n]=z.useState(.15),[r,a]=z.useState(0),[h,c]=z.useState(1),[u,o]=z.useState(!0);return z.useEffect(()=>(console.log("BallPit component mounting"),()=>{console.log("BallPit component unmounting")}),[]),p.jsx("div",{ref:i,style:{position:"absolute",top:0,left:0,width:"100%",height:"100%",zIndex:-1}})},Mt=()=>[{title:"Nice Touch - Your Vision, Our Touch"},{name:"description",content:"See what a Nice Touch can do. Join our waiting list."}];function gt(){return[{rel:"stylesheet",href:"/App.css"}]}function pt(){const[S,t]=z.useState(""),[s,i]=z.useState(!1),[e,n]=z.useState(!1);z.useEffect(()=>{console.log("App component mounted"),n(!0)},[]);const r=a=>{a.preventDefault(),console.log("Email submitted:",S),i(!0),t("")};return p.jsxs("div",{className:"landing-container",children:[e&&p.jsx(_t,{gridWidth:10,gridHeight:10,gridDepth:2}),p.jsxs("header",{className:"header",children:[p.jsx("div",{className:"brand",children:"Nice Touch"}),p.jsxs("nav",{children:[p.jsx("a",{href:"#about",children:"About"}),p.jsx("a",{href:"#contact",children:"Contact"})]})]}),p.jsx("main",{className:"main-content",children:p.jsxs("div",{className:"hero-content",children:[p.jsxs("h1",{className:"main-title",children:["YOUR TOOLS",p.jsx("br",{}),"YOUR VISION",p.jsx("br",{}),"NICE TOUCH"]}),p.jsx("p",{className:"infoline",children:"See What A Nice Touch Can Do. Join The List."}),p.jsx("div",{className:"signup-box",children:s?p.jsx("div",{className:"success-message",children:p.jsx("p",{children:"Thank you for signing up!"})}):p.jsxs("form",{onSubmit:r,className:"signup-form",children:[p.jsx("input",{type:"email",value:S,onChange:a=>t(a.target.value),placeholder:"Enter Your Email Address",required:!0}),p.jsx("button",{type:"submit",children:"SIGN UP"})]})})]})})]})}export{pt as default,gt as links,Mt as meta};
